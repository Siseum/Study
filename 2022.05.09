# 2022 05 09 

1. 영속성 컨텍스트
- 영속성 컨텍스트란 엔티티를 영구히 저장하는 환경을 의미한다.
  애플리케이션과 데이터베이스 사이에서 객체를 보관하는 가상의 데이터 베이스를 의미한다.
  엔티티 매니저를 통해 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 접근해서 해당 엔티티를 가져온다.
  
- 엔티티의 생명주기는 비영속/ 영속 / 준영속 / 삭제 4가지 상태로 분류된다.
- 엔티티의 비영속 상태는 영속성 컨텍스트와 전혀 관계없는 상태를 의미힌다.
- 엔티티의 영속 상태는 영속성 컨텍스트에서 엔티티가 관리되어지는 상태를 의미힌다.
  (* 영속 상태가 된다고 바로 DataBase에 쿼리가 전송되지 않는다 
   Transaction이 커밋하는 순간에 DataBase에 쿼리가 전송된다 *)
- 엔티티의 준영속 상태는 엔티티를 영속성 컨텍스트에서 분리한것을 의미한다.
- 엔티티의 삭제 상태는 엔티티를 DB에서 삭제한것을 의미한다.

- 영속성 컨텍스트의 이점에는
  1차 캐시 / 동일성 보장 /트랜잭션을 지원하는 쓰기지연 / 변경감지 / 지연로딩 등이 있다.

- 데이터 베이스에 데이터를 조회하면 먼저 영속성 컨텍스트 안에 있는 1차캐시를 이용하여 데이터를 조회한다는 이점이 있다.
  만약 1차 캐시에 원하는 데이터가 없다면 데이터베이스에서 해당 데이터를 가져오고 그 데이터를 1차캐쉬에 저장한다.
  (1차 캐시는 엔티티 매니저가 유지될동안 유지되며 비즈니스 로직이 끝나면 엔티티 매니저도 끝내고 1차캐쉬도 사라진다)
 
- 데이터 베이스에 있는 객체를 가져와서 비교할때 동일성 보장을 해준다는 장점이 있다.
  (영속성 컨텍스트의 1차캐쉬를 이용하여 두 객체가 동일한지 비교할 수 있다는 장점이 있다)
  
- 트랜잭션을 지원하여 쓰기 지연이 가능하다는 장점이 있다.
  엔티티 메니저는 데이터베이스에 엔티티 변경시 트랜잭션 안에서 엔티티를 변경해야된다.
  트랜잭션 안에서 앤티티를 변경한다고 바로 변경되는것이 아닌 트랜잭션 커밋을 해야 엔티티가 변경된다.
  영속성 컨텍스트에는 쓰기 지연 SQL 저장소가 있어 트랜잭션 커밋이 될때까지 쿼리문을 저장하다가
  트랜잭션 커밋이 되면 쓰기 지연 SQL 저장소에 있는 쿼리문이 실행된다.
  
- 엔티티가 JPA 코드에서 수정되었을때 변경이 감지되어 데이터베이스에 알아서 엔티티가 변경된다
  트랜잭션 커밋이 되었을때 엔티티와 맨처음 엔티티의 상태인 스냅샷을 비교하여 데이터 베이스의 수정내용을 반영한다. 
  
  
- 플러시란 영속성 컨텍스트의 변경내용을 베이스에 반영한다.
  플러시가 발생할 경우 변경이 감지되어 데이터 베이스에 수정된 엔티티 내용을 반영하고
  쓰기 지연 SQL 저장소에 있는 쿼리 내용을 데이터베이스에 전송한다.
  
  플러시를 호출하는 방법에는 
  em.flush() 메서드를 직접 호출하는 방법이 있고
  트랜잭션 커밋을 할 경우 플러시가 자동으로 호출되고
  JPQL 쿼리를 실행할경우 플러시가 자동으로 호출된다.
  
  플러시는 영속성 컨텍스트를 비우지 않고
  영속성 컨텍스트의 변경내용을 데이터베이스에 동기화 한다.
  
  
- 준영속 상태란 영속 상태의 엔티티가 영속성 컨텍스트에서 분리됨을 의미한다
  준영속 상태일때는 영속성 컨텍스트가 제공하는 기능을 사용하지 못한다 (변경 감지를 사용할 수 없다)
  
  준영속 상태는 
  em.detach(entity); 메서드를 호출하여 특정 엔티티만 준영속 상태로 만들 수 있다
  em.clear(); 메서드를 호출하여 영속성 컨텍스트를 완전히 초기화 상태로 만들 수 있다.
  em.close(); 메서드를 호출하여 영속성 컨텍스트를 종료시킬 수 있다.
  
  준영속 상태는 데이터베이스에서 삭제하는것이 아닌 JPA에서 관리되지 않는 상태를 만드는 것이다.
  
- 삭제 상태는 em.remove(member); 메서드를 호출하여 특정 엔티티 객체를 데이터 베이스에서 삭제하는것을 의미한다.


2. 엔티티 매핑
- 엔티티 매핑이란 엔티티 객체와 데이터 베이스 테이블을 매핑하는것을 의미한다.
- @Entity가 붙은 클래스는 JPA가 관리하고 엔티티라고 한다.
  JPA를 사용해서 테이블과 매핑할 클래스는 @Entity가 필수이다.
  (@Entity를 적용할 객체는 기본생성자가 필수이다(public, protected 생성자)
   final 클래스, enum, interface, innter 클래스는 @Entity 어노테이션 적용이 안된다.
   적용할 필드에 final을 사용할 수 없다)

- @Entity 어노테이션의 name 속성은 Entity의 이름을 설정한다.
- @Table 어노테이션의 엔티티와 매핑할 테이블을 지정한다.


- JPA는 데이터 베이스 스키마를 자동으로 생성할 수 있다.
  DDL을 애플리케이션 실행시점에 자동으로 생성할 수 있다.
  (DDL이란 Data Definiation Language / 데이터베이스 스키마를 정의하거나 조작하는 언어이다
   CREATE / ALTER / DROP 명령어 등 )
  
  JPA가 DDL을 자동으로 생성할라면 데이터베이스 스키마 자동생성 속성을 설정해야되는데
  create 설정은 기존 테이블을 삭제하고 다시 생성한다.
  create-drop 설정은 create와 같으나 종료시점에 drop 한다는 특징이 있다.
  update 설정은 변경된 부분만 반영한다 (운영 DB에서 사용하면 안된다)
  validate 설정은 엔티티와 테이블이 정상 매핑되어있는지 확인한다.
  none 설정은 JPA 데이터베이스 스키마 자동생성 옵션을 사용하지 않는다는 설정이다.


- @Id 어노테이션은 데이터 베이스의 기본키와 매핑하는 어노테이션이다
  @Column 어노테이션은 데이터 베이스의 열과 객체의 맴버변수와 매핑하는 어노테이션이다
  (@Column name = 'name' 어노테이션은 데이터 베이스의 name 열과 매핑하는 어노테이션이다)
  @Enumerated 어노테이션은 enum 타입과 매핑한다
  
  (@Enumarated 어노테이션을 사용할때 EnumType.STRING 옵션을 사용해야된다.
   EnumType.ORDINAL 속성은 enum의 순서를 데이터베이스에 저장하지만
   문제점은 EnumType의 값이 변경될 경우 순서도 변경되므로 문제가 발생한다
   그러므로 EnumType.STRING 옵션을 사용해야된다)
   
  @Temporal 어노테이션은 날짜 타입과 매핑한다.
  (@Temporal 어노테이션에는 DATE(날짜), TIME(시간), TIMESTAMP(날짜와 시간)가 있다)
  @Lob 어노테이션은 varchar보다 큰 데이터를 넣고 싶을때 사용하는 어노테이션이다
  @Transient 어노테이션은 특정 필드를 컬럼에 매핑하지 않을때 사용하는 어노테이션이다.
  
  
3. 기본키 매핑
- 기본키를 직접 할당할려면 @Id 어노테이션을 사용한다

 기본키를 자동으로 생성할려면 @GeneratedValue 어노테이션을 사용한다
 @GeneratedValue 어노테이션의 strategy 속성값이 있는데 strategy 속성값에 따라
 기본키가 자동으로 생성되는 방법이 달라진다.
 @GeneratedValue 어노테이션의 strategy에는 IDENTITY / SEQUENCE / TABLE / AUTO가 있다
 - IDENTITY 전략에는 기본 키 생성을 데이터 베이스에 위임한다
   영속성 컨텍스트에 엔티티를 등록하기 위해서 기본 키 값을 알아야되는데 IDENTITY 전략에서는 
   데이터 베이스에 저장될때까지 기본 키값을 알 수 없으므로 em.persist() 메서드를 실행하면
   지연쓰기를 하지않고 바로 데이터 베이스에 쿼리를 전송한다.
   (MySQL에서 주로 사용하고 MySQL의 AUTO_INCREAMENT와 비슷하다)
   
 - SEQUENCE 전략은 유일한 값을 순서대로 생성하는 특별한 데이터 베이스 오브젝트로
   기본 키 값을 설정하는 방법이다 (예를들면 오라클 시퀀스가 있다)
   영속성 컨텍스트에 엔티티를 등록하기 위해서 기본 키 값을 알아야되는데 SEQUENCE 전략에는
   em.persist() 시점에 시퀀스를 조회하는 쿼리를 DB에 전달하여 nextValue를 기본 키값으로 받고 
   영속성 컨텍스트에 등록한다.
   
   SEQUENCE 전략에는 allocationSize 속성을 이용하여 성능 최적화를 할 수 있는데
   allocationSize 속성을 이용하여 한꺼번에 시퀀스를 가져오는 값을 설정할 수 있어 성능 최적화를 할 수 있다.
   
 - TABLE 전략은 키 생성 전용 테이블을 하나 만들어서 데이터 베이스 시퀀스를 모방하는 전략이다
   장점은 모든 데이터 베이스에 적용이 된다는 특징이 있지만 성능이 좋지 않을 수 있다는 문제점이 있다.
   
 - 권장하는 기본 키 제약조건은 null이 아니여야되고 유일해야되고 변하면 안된다.
   이런 조건을 찾기 어려우므로 대키를 사용하는것을 권장한다
   
 
 
 
 
  
