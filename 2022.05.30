# 2022 05 30 Study

1. API를 설계할 떄는 요청값으로 엔티티를 직접 받지 않아야 한다 
   엔티티를 직접 입력받을 경우 엔티티에 API 검증을 위한 로직이 들어간다 (@NotEmpty 등)
   엔티티에 API 검증을 위한 로직이 들어갈 경우 여러 조건을 만족하는 API 검증 로직을 처리하는것이 어려워진다
   (엔티티에 프레젠테이션 계층을 위한 로직이 추가된다는 문제점이 있다)
   엔티티를 변경할 경우 API 스펙이 변경된다는 문제점이 있다
   
   그러므로 엔티티를 직접 입력받지 말고 API 요청에 맞는 DTO 클래스를 만들어 파라미터로 입력받는다
   (DTO란 Data Transfer Object로 계층간 데이터 교환을 위해 사용하는 객체로 비즈니스 로직이 없는 순수한 데이터 객체를 의미한다)
   
   엔티티 대신 DTO를 @RequestBody에 매핑할 경우 
   엔티티와 프레젠테이션 계층을 위한 로직을 분리할 수 있고 엔티티와 API 스펙을 명확하게 분리할 수 있다
   엔티티가 변해도 API 스펙이 변하지 않는다는 장점이 있다
   
   List를 @ResponseBody로 그대로 반환할 경우 문제점은 반환되는 Json 양식을 확장할 수 없다는 단점이 있다
   List를 그대로 반환할 경우 배열 형식으로 데이터만 반환되어 Json 양식에 정보를 추가할 수 없는데 (데이터 총 개수 등)
   이를 해결하기 위해 List를 그냥 반환하는것이 아닌 반환 DTO를 따로 만들어 매핑하여 반환하는 형태로 설계해야된다.
   
   @RequestBody 어노테이션은 Json 전달받은 데이터를 클래스 객체와 매핑하는 어노테이션이다
   @ResponseBody 어노테이션은 반환하는 클래스 객체를 Json으로 매핑하여 반환하는 어노테이션이다.
   
   엔티티를 수정할 경우 변경 감지와 병합 기능이 있는데 
   엔티티를 조회해서 영속성 상태로 만든 뒤 변경 감지로 엔티티를 수정하는 것이 좋다.
   (병합 기능 사용시 데이터가 의도치 않게 수정될 수 있으므로 변경 감지를 이용하여 엔티티 데이터를 수정하는 것이 좋다)
   
   
2. API 개발을 위한 샘플용 데이터 입력
   API 개발을 위한 데이터를 매번 새로 입력할 수 없으므로 샘플용 데이터를 입력하는 클래스인 InitDB 클래스를 만들고
   InitDB 클래스를 만들어 샘플용 데이터를 추가하도록 하였다
   
   @PostConstruct 어노테이션이란 Spring Bean을 초기화 한 이후에 
   @PostConstruct 어노테이션이 붙은 메서드를 딱 한번 실행시켜주는 어노테이션이다.
   
   내부 클래스를 사용할 경우 static 키워드를 붙이는 것이 좋다 
   static이 아닌 멤버 클래스의 인스턴스는 바깥 클래스의 인스턴스와 암묵적으로 연결된다
   그러므로 외부 클래스와 내부 클래스의 관계는 맴버 클래스의 인스턴스 안에 만들어지며 메모리를 차지하고 생성도 느려진다
   바깥 인스턴스에 대한 참조가 존재하는데 가비지 컬렉션이 인스턴스 수거를 하지 못하므로 메모리 누수가 생길 수 있다.
   그러므로 내부 클래스를 사용할 경우 static 키워드를 붙이는것이 좋다
   (만약 내부클래스에서 외부 클래스의 맴버 변수나 맴버 메서드에 접근할 경우 static을 제거해야된다
    하지만 그렇지 않는다라면 내부 클래스에 static 키워드를 붙이는 것이 좋다)
    
    내부 클래스를 사용하는 이유
    외부 클래스와 내부 클래스가 긴밀한 관계를 맺을 떄 사용한다 
    내부 클래스에서 외부 클래스의 맴버에 쉽게 접근할 수 있다
    서로 관련있는 코드를 모아서 코드의 캡슐화를 증가시킨다
    (캡슐화란 연관된 목적을 가진 변수와 함수를 하나의 클래스로 모아서 쉽게 접근하지 못하도록 은닉하는것을 의미한다)
    
    
3. 연관된 엔티티를 조회할때는 지연 로딩 전략을 사용해야된다
   즉시로딩 방식은 연관 관계가 필요 없는 경우에도 데이터를 항상 조회해서 성능 문제가 발생할 수 있다
   즉시 로딩으로 설정하면 성능 개선이 매우 어려워 지므로 지연 로딩 전략을 사용해야 된다
   지연 로딩에서 성능 최적화가 필요한 경우 페치 조인(fetch join)을 사용한다
   
   지연로딩이란 자신과 연관된 엔티티를 실제로 사용할 떄 연관된 엔티티를 조회(SELECT)하는 것을 의미한다
   즉시로딩이란 엔티티를 조회할때 자신과 연관되는 엔티티를 조인(JOIN)을 통해 함께 조회하는 방식을 의미한다
   프록시란 데이터 베이스 조회를 미루는 가짜(프록시) 엔티티 객체를 의미한다 
   (지연로딩은 영속성 컨텍스트에 있는 엔티티를 사용하고 없으면 SQL을 실행한다 
    그러므로 영속성 컨텍스트에서 이미 로딩한 엔티티를 추가로 조회하면 SQL을 실행하지 않는다)
   
   연관된 엔티티들을 함께 조회할때 엔티티를 직접 반환하는것은 좋지 않다
   그 이유는 위에서 언급한 엔티티가 변경될 경우 API 스펙 변경 등의 이유와 
   엔티티를 Json으로 변환시 순환 참조의 문제등이 있으므로 엔티티를 직접 반환하지 말아야 된다.
   (위에서 언급한건처럼 Json으로 반환할 DTO 클래스를 만들어서 반환한다)

   페치 조인을 사용하지 않고 DTO를 만들어서 반환할 경우 N+1 문제가 발생한다
   예) Order / Member / Delivery 엔티티가 있다면
   Order와 Member는 다대일 / Order와 Delivery는 일대일 관계이다
   Order가 2개라고 가정한다면
   먼저 Order를 조회하는 쿼리 1번이 발생하고 Order에서 Member와 Delivery를 각각 조회해야 되므로 총2번 쿼리가 발생하고
   Order가 1개 더 있으므로 다시 Member와 Delivery를 각각 조회하는 쿼리가 총 2번발생한다
   즉 1번을 조회했더니 2+2개의 쿼리가 더 발생했는데 이러한 문제를 N+1 문제라고 한다
   (N+1 문제란 1번의 쿼리를 실행했는데 의도하지 않는 N번의 쿼리가 추가적으로 실행되는 문제를 의미한다)
   
   N+1 문제를 해결하기 위해 페치 조인(fetch join)을 사용해서 쿼리 1번에 조회해서 성능을 최적화 한다
   (페치 조인을 할 경우 지연로딩을 무시하고 즉시 로딩을 한다)
   (페치 조인이란 연관된 엔티티나 컬렉션을 한번에 같이 조회하는 기능을 의미한다)
   
   페치 조인의 문제점은 모든 column이 조회되므로 필요없는 column도 같이 조회된다는 문제점이 있다
   그래서 DTO를 만들어 페치 조인을 할 경우 해당 DTO에 매핑하여 원하는 데이터만 조회할 수 있다 
   (select 절에 new 명령어를 이용하여 해당 DTO 객체를 생성하는 문장을 넣는다 그리고 해당 DTO 클래스의 경로명까지 다 적어줘야 된다)
   하지만 이렇게 조회할 경우 리포지토리의 재사용성이 낮고 API 스펙에 맞춘 코드가 리포지토리에 들어간다는 단점이 있다.
    
   
   
   
   
 
