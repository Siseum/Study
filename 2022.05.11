# 2022 05 11 Study

1. 프록시
- 프록시란 데이터 베이스 조회를 지연시키는 가짜 엔티티 객체를 의미한다.
  프록시를 사용하는 이유는 하나의 엔티티를 조회할때 그와 관련된 엔티티를 동시에 조회되는데
  프록시 객체를 이용하여 하나의 엔티티를 조회할때 필요한 부분만 조회가 되고
  다른 부분은 필요할때 조회하도록 지연시키기 위해 프록시 객체를 사용한다.
  
  em.find() 메서드를 호출하면 데이터 베이스를 통해 실제 엔티티 객체가 조회된다
  (엔티티란 DB테이블에 해당되는 하나의 클래스를 의미한다)
  em.getReference() 메서드를 호출하면 데이터 베이스 조회를 지연시키는 가짜(프록시) 엔티티 객체가 조회된다.
  
  프록시 객체의 특징은
  실제 클래스를 상속받아 만들어진다.
  실제 클래스와 겉 모양이 같다
  프록시 객체는 실제 객체의 참조를 보관한다
  프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드를 호출한다.
  
  em.getReference()로 프록시 객체를 생성하고
  getName() 메서드 같이 데이터 베이스에서 실제 데이터를 요청하면
  영속성 컨텍스트가 DB를 조회해서 해당 Entity를 생성하고
  프록시 객체는 실제 Entity를 가르키면서 프록시 객체가 초기화된다.
  
  프록시 객체는 처음 사용할때 한번만 초기화된다
  프록시 객체를 초기화 할 때 프록시 객체가 실제 엔티티로 변경되는것이 아니다 
  프록시 객체가 초기화 되면 프록시 객체를 통해서 실제 엔티티에 접근이 가능하다.
  프록시 객체는 원본 엔티티를 상속받으므로 타입 체크시 == 연산이 아닌 instanceOf로 타입을 체크해야된다.
  
  프록시 객체가 먼저 초기화되면 em.find() 메서드를 호출해도 프록시 객체가 반환된다
  영속성 컨텍스트에 엔티티가 있다면 em.getReference() 메서드를 호출해도 실제 Entity가 반환된다.
  영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일때 프록시를 초기화하면 문제가 발생한다
  (hibernate.LazyInitializationException 예외를 발생시킨다)
  
 
2. 즉시로딩과 지연로딩
- 즉시로딩이란 데이터를 조회할때 연관된 데이터를 한꺼번에 조회하는 방식이다
  지연로딩이란 데이터를 조회할때 필요한 시점에 데이터를 조회하는 방식이다
  
  실무에서는 되도록이면 지연로딩만 사용해야된다
  즉시로딩을 사용할 경우 예상치 못한 SQL문제가 발생하는데
  특히 N+1 문제를 발생시킬 수 있다
  (N+1 문제란 조회시 1개의 쿼리를 생각했으나 나오지 않아도 되는 쿼리 N개가 더 발생하는 문제를 의미한다.)
  @ManyToOne, @OneToOne의 기본 값은 즉시로딩이므로 LAZY로 설정해야된다
  (@OneToMany, @ManyToMany는 기본이 지연로딩이다)
  
  
3. 영속성 전이
- 영속성 전이란 특정 엔티티를 영속 상태로 만들때 연관된 엔티티도 함께 영속 상태로 만드는 문법이다.
  영속성 전이는 연관관계를 매핑하는것과 아무 관련이 없다
  엔티티를 영속화 할 때 연관된 엔티티도 함께 영속화 하는 편리함을 제공할 뿐이다.
  
- 고아 객체 제거란 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 문법이다
   
  cascade.removal과 orpahnRemoval=true의 차이점
  cascade.removal에서 부모 객체가 보관하고 있는 자식 객체의 컬랙션(list 등)을 제거할 경우
  자식 객체들도 같이 삭제되지만
  부모 객체가 보관하고 있는 자식 객체의 컬랙션중에서 자식 객체를 한개만 제거할 경우 자식 객체는 삭제되지 않는다
  
  orphanRemoval=true에서 부모 객체가 보관하고 있는 자식 객체의 컬랙션(list 등)을 제거할 경우
  자식 객체들도 같이 삭제된다
  부모 객체가 보관하고 있는 자식 객체의 컬랙션중에서 자식 객체를 한개만 제거할 경우 부모 자식관계가 사라지면서 자식객체가 삭제된다
  
  영속성 전이나 고아 객체 제거를 사용할 때 주의할점은 참조하는 곳이 하나일 때 사용해야된다.
  
  CascadeType.ALL + orphanRemoval=true 를 같이 사용할 경우
  em.persist()로 영속화와 em.remove()로 제거가 가능하여 부모 엔티티를 통해서 자식의 생명주기를 관리할 수 있게 된다.
  
 
4. 값타임
- JPA는 엔티티 타입과 값 타입으로 분류한다
  엔티티 타입이란 @Entity로 정의하는 객체를 의미한다.
  값 타입이란 int, Integer, String 처럼 단순 값으로 사용하는 자바 기본 타입이나 객체를 의미한다
  식별자가 없고 추적이 불가능하며 생명주기를 엔티티에 의존한다는 특징이 있다
  
  값타입에는 기본값 타입 / 임베디드 타입/ 컬렉션 값 타입이 있다
  
- 임베디드 타입이란 새로운 값을 정의하여 사용하는 값 타입이다
  @Embeddable 어노테이션은 값 타입을 정의하는 곳에 표시하는 어노테이션이다
  @Embedded 어노테이션은 값 타입을 사용하는 곳에 표시하는 어노테이션이다
  임베디드 타입은 기본생성자가 필요하다
  임메비드 타입을 포함한 값 타입은 값 타입을 소유한 엔티티에 생명주기를 의존한다.
  
  임베디드 타입은 재사용 / 응집도가 높고
  해당 값 타입만 사용하는 의미있는 메서드를 만들 수 있는 장점이 있다.
  
  한 엔티티에서 같은 값 타입을 사용하면 Column 명이 중복되므로
  @AttributeOverride / @AttributeOverrides 어노테이션으로 컬럼명을 재정의 한다
  
  값 타입을 여러 엔티티에서 공유하면 여러 부작용들이 발생할 수 있다
  (한곳에서 수정한 값 타입이 다른 엔티티에도 영향을 끼치는 부작용 등이 발생할 수 있다)
  그러므로 값 타입의 실제 인스턴스 값을 공유하는것은 위험하고 대신 인스턴스의 내용들을 복사해서 사용한다.
  
  객체 타입은 참조값을 대입하는것을 막을 방법이 없으므로 불변 객체로 만들어 값을 수정할 수 없도록 만든다
  (불변 객체란 생성시점 이후로 절대 값을 변경할 수 없는 객체를 의미한다)
  
  값 타입은 인스턴스가 달라도 그 안에 값이 같으면 같은것이라고 봐야된다 
  그래서 값 타입은 == 연산자가 아닌 equals() 메소드를 이용하여 값 타입을 비교해야된다
  
- 값 타입 컬랙션이란 값 타입을 컬렉션에 저장해서 쓰는것을 의미한다
  데이터 베이스는 컬랙션을 표현할 수 없으므로 일대다 / 다대일 관계로 값 타입 컬랙션을 표현해야된다.
  
  @ElementCollection 어노테이션은 값 타입 컬랙션 객체임을 JPA에게 알려주는 어노테이션이다.
  @CollectionTable 어노테이션은 값 타입 컬랙션과 매핑할 테이블을 설정하는 어노테이션이다.
  @JoinColumn 어노테이션은 외래키를 매핑할때 사용하는 어노테이션이다. 
  
  값 타입 컬랙션은 지연 로딩을 사용한다
  값 타입 컬랙션은 영속성 전이(Cascade)와 고아 객체 제거 기능을 필수로 가진다는 특징이 있다
  
  값 타입은 엔티티와 다르게 식별자 개념이 없다
  값 타입은 변경하면 추적이 어렵다
  값 타입 컬랙션에 변경사항이 발생하면 주인 엔티티와 관련된 모든 데이터들을 삭제하고
  값 타입 컬랙션에 있는 현재값을 모두 다시 저장한다는 특징이 있다

  값 타입 컬랙션을 수정할 경우 모든 데이터를 삭제하고 모두 다시 저장한다는 문제점이 있으므로
  실무에서는 값 타입 컬랙션 대신 일대다 관계를 고려해야된다 
  영속성 전이(Cascade)와 고아 객체 제거를 사용해 값 타입 컬랙션처럼 사용한다.
  
  엔티티 타입의 특징은 식별자가 있다 / 생명주기를 엔티티가 관리한다 / 공유해도 된다라는 특징이 있고
  값 타입의 특징은 식별자가 없다 / 생명주기를 엔티티에 의존한다 / 공유하지 않는것이 안전하다(복사해서 사용해야된다)라는 특징이 있다.
 
  
