# 2022 05 11 Study

1. 프록시
- 프록시란 데이터 베이스 조회를 지연시키는 가짜 엔티티 객체를 의미한다.
  프록시를 사용하는 이유는 하나의 엔티티를 조회할때 그와 관련된 엔티티를 동시에 조회되는데
  프록시 객체를 이용하여 하나의 엔티티를 조회할때 필요한 부분만 조회가 되고
  다른 부분은 필요할때 조회하도록 지연시키기 위해 프록시 객체를 사용한다.
  
  em.find() 메서드를 호출하면 데이터 베이스를 통해 실제 엔티티 객체가 조회된다
  (엔티티란 DB테이블에 해당되는 하나의 클래스를 의미한다)
  em.getReference() 메서드를 호출하면 데이터 베이스 조회를 지연시키는 가짜(프록시) 엔티티 객체가 조회된다.
  
  프록시 객체의 특징은
  실제 클래스를 상속받아 만들어진다.
  실제 클래스와 겉 모양이 같다
  프록시 객체는 실제 객체의 참조를 보관한다
  프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드를 호출한다.
  
  em.getReference()로 프록시 객체를 생성하고
  getName() 메서드 같이 데이터 베이스에서 실제 데이터를 요청하면
  영속성 컨텍스트가 DB를 조회해서 해당 Entity를 생성하고
  프록시 객체는 실제 Entity를 가르키면서 프록시 객체가 초기화된다.
  
  프록시 객체는 처음 사용할때 한번만 초기화된다
  프록시 객체를 초기화 할 때 프록시 객체가 실제 엔티티로 변경되는것이 아니다 
  프록시 객체가 초기화 되면 프록시 객체를 통해서 실제 엔티티에 접근이 가능하다.
  프록시 객체는 원본 엔티티를 상속받으므로 타입 체크시 == 연산이 아닌 instanceOf로 타입을 체크해야된다.
  
  프록시 객체가 먼저 초기화되면 em.find() 메서드를 호출해도 프록시 객체가 반환된다
  영속성 컨텍스트에 엔티티가 있다면 em.getReference() 메서드를 호출해도 실제 Entity가 반환된다.
  영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일때 프록시를 초기화하면 문제가 발생한다
  (hibernate.LazyInitializationException 예외를 발생시킨다)
  
 
2. 즉시로딩과 지연로딩
- 즉시로딩이란 데이터를 조회할때 연관된 데이터를 한꺼번에 조회하는 방식이다
  지연로딩이란 데이터를 조회할때 필요한 시점에 데이터를 조회하는 방식이다
  
  실무에서는 되도록이면 지연로딩만 사용해야된다
  즉시로딩을 사용할 경우 예상치 못한 SQL문제가 발생하는데
  특히 N+1 문제를 발생시킬 수 있다
  (N+1 문제란 조회시 1개의 쿼리를 생각했으나 나오지 않아도 되는 쿼리 N개가 더 발생하는 문제를 의미한다.)
  @ManyToOne, @OneToOne의 기본 값은 즉시로딩이므로 LAZY로 설정해야된다
  (@OneToMany, @ManyToMany는 기본이 지연로딩이다)
  
  
3. 영속성 전이
- 영속성 전이란 특정 엔티티를 영속 상태로 만들때 연관된 엔티티도 함께 영속 상태로 만드는 문법이다.
  영속성 전이는 연관관계를 매핑하는것과 아무 관련이 없다
  엔티티를 영속화 할 때 연관된 엔티티도 함께 영속화 하는 편리함을 제공할 뿐이다.
  
- 고아 객체 제거란 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 문법이다
   
  cascade.removal과 orpahnRemoval=true의 차이점
  cascade.removal에서 부모 객체가 보관하고 있는 자식 객체의 컬랙션(list 등)을 제거할 경우
  자식 객체들도 같이 삭제되지만
  부모 객체가 보관하고 있는 자식 객체의 컬랙션중에서 자식 객체를 한개만 제거할 경우 자식 객체는 삭제되지 않는다
  
  orphanRemoval=true에서 부모 객체가 보관하고 있는 자식 객체의 컬랙션(list 등)을 제거할 경우
  자식 객체들도 같이 삭제된다
  부모 객체가 보관하고 있는 자식 객체의 컬랙션중에서 자식 객체를 한개만 제거할 경우 부모 자식관계가 사라지면서 자식객체가 삭제된다
  
  영속성 전이나 고아 객체 제거를 사용할 때 주의할점은 참조하는 곳이 하나일 때 사용해야된다.
  
  CascadeType.ALL + orphanRemoval=true 를 같이 사용할 경우
  em.persist()로 영속화와 em.remove()로 제거가 가능하여 부모 엔티티를 통해서 자식의 생명주기를 관리할 수 있게 된다.
  
  
  
  
  
  
