# 2022 05 25 Study

인프런 강의 실전! 스프링 부트와 JPA 활용1 강의를 듣고 공부한 내용 리뷰

1. 회원 컨트롤러를 만들어서 회원에 관한 웹페이지 요청사항을 처리하였다.
   웹에서 회원을 등록시키는 페이지의 요청을 처리하는 함수인 createForm() 메서드를 생성하였는데
   회원을 등록하기 위해 입력하는 정보를 담는 MemberForm 클래스를 만들고 Model 객체에 등록하였다
   그리고 MemberForm 객체를 등록한 Model 객체를 화면(웹 페이지)로 전달 하였다.
   
   회원 정보를 등록시킬 memberForm 클래스를 웹페이지로 전달한 뒤 
   웹페이지에서 입력받은 memberForm 정보를 이용하여 회원을 등록시키는 create() 메서드를 만들었다. 
   create() 메서드는 웹 페이지에서 입력받은 memberForm의 정보를 인자로 전달받는데
   MemberForm 객체에서 이름이 등록되지 않을 경우 에러를 발생시켜야 하므로
   해당값이 유효한지 체크하는 어노테이션 @NotEmpty 어노테이션을 사용하여
   이름에 아무 값도 들어있지 않으면 에러 메세지를 출력하도록 하였다.
   (@Valid 어노테이션이란 제약 조건을 달아놓은 속성에 대해 유효 값 검사를 하는 어노테이션이다)
   그리고 유효값 검사를 하여 에러가 있는지 없는지 결과를 저장하는 BindingResult를 이용하여 에러가 있는지 확인하였다
   아무런 문제가 없으면 memberForm의 정보를 이용하여 member 객체를 만들고 회원을 데이터 베이스에 등록하였다.
   
   회원 정보의 리스트를 웹 페이지로 전달하는 list() 메서드를 만들었다
   Model 객체를 이용하여 해당 회원 정보 리스트를 저장한 뒤 회원 정보를 저장한 Model 객체를
   회원 정보를 출력하는 웹페이지로 전달하였다.
   
   웹페이지에서 정보를 받을때 엔티티를 직접 사용하여 정보를 저장하는것이 아닌 폼 객체를 사용해서 
   웹페이지에서 입력한 정보를 저장하는것이 좋은 방법인데 그 이유는 요구사항이 점점 복잡해지면
   엔티티에서 화면을 처리하는 기능이 점점 증가하여 화면에 종속적이게 되고 그로 인해 유지보수가 어려워지게 된다
   실무에서는 엔티티는 핵심 비즈니스 로직만 가지고 있고 화면을 위한 로직은 없어야 된다.
   화면이나 API에 맞는 폼 객체나 DTO를 사용하여 화면이나 API의 요구사항들을 처리하고
   엔티티는 최대한 비즈니스 로직에 맞도록 유지해야된다.
   
   
2. 상품 컨트롤러를 만들어서 상품에 관한 웹페이지 요청사항을 처리하였다.
   상품을 등록하기 전에 상품의 정보를 저장하는 BookForm 객체를 생성하여 Model 객체에 저장한 뒤
   그 Model 객체를 상품을 등록하는 웹페이지로 전달하여 웹페이지에서 등록한 상품 정보를 BookForm 객체에 저장하도록 하였다.
   
   상품을 데이터 베이스에 등록하는 create() 메서드는 웹페이지에서 상품 정보를 저장한 BookForm 객체를 인자로 전달받고
   그 정보를 이용하여 Book 객체를 새로 생성한다. 그리고 그 생성한 Book 객체를 데이터 베이스에 저장한다.
   
   상품 정보의 목록들을 조회하는 list() 메서드는 Model 객체를 이용하여 상품 목록들을 저장하고
   그 Model 객체를 상품 정보를 조회하는 웹 페이지에 전달하였다.
   
   상품 정보를 수정할려는 웹페이지에 원래의 상품정보를 전달해주는 updateItemForm() 메서드를 생성하였다
   상품 정보를 요청하는 웹 페이지에서 상품 정보의 id를 인자로 전달받아 상품 정보의 id로 해당 상품을 조회하고
   조회한 상품의 정보로 BookForm 객체를 생성한다. 
   그리고 BookForm 객체를 Model에 등록해서 상품 정보를 수정하는 페이지로 전달하였다.
  
   상품을 수정하여 데이터 베이스에 저정하는 메서드인 updateItem() 메서드를 생성하였다
   updateItem() 메서드에서는 상품의 정보를 수정하는 id와 상품 정보 수정 웹페이지에서 수정한 BookForm 객체를 인자로 전달 받았다.
   변경 감지 기능을 이용하여 상품의 정보를 수정하기 위해서 ItemService 객체의 updateItem() 메서드에서 수정할 상품을 조회하고
   상품의 정보들을 수정하도록 하였다
   
   
   준영속 엔티티란 영속성 컨텍스트에서 더는 관리하지 않는 엔티티를 말한다.
   (updateItem() 메서드에서 Book을 생성하여 기존 Book의 정보를 세팅할 경우 데이터 베이스에는 데이터가 존재하지만
   영속성 컨텍스트에서 관리하지 않는 준영속 상태가 된다. 이렇게 임의로 만들어낸 엔티티도 기존 식별자(id)가 존재한다면
   준영속 상태로 볼 수 있다)
   
   이러한 준영속 상태를 변경하는 방법에는 변경 감지 기능과 병합 기능이 있다
   변경 감지 기능은 em.find() 같이 영속성 컨텍스트에서 엔티티를 조회한 뒤 데이터를 수정하는 방법이다
   트랜잭션(@Transaction) 안에서 엔티티를 조회하고 조회한 엔티티를 수정할 경우
   조회한 엔티티는 영속성 컨텍스트에 등록되어 트랜잭션 커밋 시점에 변경 감지가 작동해서 데이터 베이스에 UPDATE SQL이 실행된다.

   병합 기능은 준영속 상태의 엔티티를 영속 상태로 변경할 때 사용하는 기능이다
   em.merge() 메서드를 이용하여 준영속 상태의 엔티티를 데이터 베이스에 저장한다.
   
   병합 기능은 준영속 엔티티의 식별자 값으로 영속 엔티티를 조회하고
   영속 엔티티의 값을 준영속 상태의 엔티티 값을 모두 교체한다
   트랜잭션 커밋 시점에서 변경 감지 기능이 동작해서 데이터베이스에 UPDATE SQL이 실행된다
   
   변경 감지 기능을 사용하면 원하는 속성만 선택해서 값을 변경할 수 있지만 병합을 사용하면 모든 속성이 변경된다.
   병합시 값이 없으면 NULL로 업데이트 할 위험도 있다 (병합은 모든 필드를 교체한다)
   
   엔티티를 변경할 경우 
   항상 변경 감지를 사용하는것이 좋다
   컨트롤러에서에서 엔티티를 생성하지 말고 트랜잭션이 있는 서비스 계층에서 
   영속 상태의 엔티티를 조회하고 엔티티의 데이터를 직접 변경한다.
   트랜잭션 커밋 시점에 변경 감지가 실행된다.
   

3. 주문 컨트롤러를 만들어서 주문에 관한 웹페이지 요청사항을 처리하였다.
   주문을 요청하기전에 고객의 list와 상품의 list 정보를 Model 객체에 저장하여
   주문을 신청하는 웹페이지에 Model 객체를 전달하였다.

   고객의 list와 상품의 list의 정보를 저장한 Model 객체의 정보들을 주문을 신청하는 웹 페이지에 표현했고 
   Model 객체의 정보들을 선택하여 주문을 신청하면 order() 메서드에 회원의 id와 상품의 id와 상품 수량을 인자로 전달하여
   상품을 주문하는 OrderService.order() 메서드를 실행하도록 하였다.
   주문하는 OrderService.order() 메서드에서 save() 메서드를 실행하여 주문 엔티티를 데이터 베이스에 저장하도록 하였다.
   (OrderService.order() 메서드에서는 회원 id와 상품 id로 회원과 상품을 조회하였고 회원 정보로 배송 객체를 생성하였다
   상품 정보로 상품주문 객체를 생성하고 회원 / 배송 / 상품주문 객체로 주문 객체를 생성하였다.
   주문 객체의 createOrder() 메서드는 회원을 등록하고 배송 정보를 등록하고 상품에 있는 상품정보를 등록하고 
   주문의 상태를 Order로 변경하고 날짜를 등록하는 메서드이다)
   
   주문을 조회할때는 여러가지 조건으로 필터링 하여 검색할 수 있도록 하였다
   그래서 웹페이지에서 검색을 위한 조건들의 정보를 orderSearch 라는 객체에 인자로 전달 받았다
   orderService.findOrder() 메서드에 orderSearch 객체를 인자로 사용하여 해당 조건에 맞는 주문 리스트들을 조회하였고
   Model 객체를 이용하여 해당 검색 조건에 맞는 리스트들을 웹 페이지에 전달하도록 하였다
   
   주문을 취소하는 메서드인 cancelOrder() 메서드를 생성하였는데 
   주문의 id를 인자로 전달받아 주문을 취소하도록 하였다.
   
   @RequestParam 어노테이션이란 URL Parameter를 전달받기 위해 사용하는 어노테이션이다
   @RequestBody 어노테이션이란 웹 페이지에서 전달한 Json 파일을 특정 클래스 객체로 변환시키는 어노테이션이다
   (@RequestBody 어노테이션은 바인딩이 아닌 변환을 시키는 것이므로 Setter가 없어도 변환이 된다)
   @ModelAttribute 어노테이션이란 웹 페이지에서 전달한 Json 파일이나 URL Parameter를 특정 객체나 변수에 바인딩시키는 어노테이션이다
   (@ModelAttribute 어노테이션은 변환이 아닌 바인딩이므로 Setter가 없을 경우 바인딩이 되지 않는다)
   
   
   
