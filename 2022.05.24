# 2022 05 24 Study 

인프런 강의 실전! 스프링 부트와 JPA 활용1 강의를 듣고 공부한 내용 리뷰

1. 엔티티 설계시 주의점

- 엔티티에는 가급적 Setter를 사용하지 말자
  Setter가 모두 열려있을 경우 변경 포인트가 많아 유지보수가 어렵다 / 나중에 리펙토링으로 Setter를 제거한다 
  
- 모든 연관관계는 지연로딩(LAZY)으로 설정한다
  즉시 로딩(EAGER)은 예측이 어렵고 어떤 SQL이 실행될지 추척하기 어렵다 
  특히 즉시로딩 설정에서 JPQL을 실행할때 N+1 문제가 자주 발생한다.
  연관된 엔티티를 함께 DB에서 조회하면 fetch join 또는 엔티티 그래프 기능을 이용한다
  XToOne(OneToOne, ManyToOne) 관계는 기본이 즉시 로딩이므로 직접 지연로딩으로 설정해야 한다.
  
  즉시로딩(EAGER)란 데이터를 조회할 때 연관된 모든 객체의 데이터까지 한번에 불러오는것이다
  지연로딩(LAZY)란 필요한 시점에 연관된 객체의 데이터를 불러오는것이다.
  
  N+1 문제란 엔티티(1)를 조회할 때 연관관계의 데이터 개수(N)만큼 조회 쿼리가 추가로 발생하는 문제를 의미한다.
  (지연 로딩을 할 경우 해당 entity를 프록시로 설정하고 해당 entity를 사용할때 쿼리문을 데이터베이스에 전달하는데
  처음 find를 할 경우 N+1이 발생하지 않지만 추가로 Entity의 내용을 사용할때 Entity 프록시 객체에 대한 쿼리를 발생하므로
  결국 지연로딩에서도 N+1 문제가 발생한다)
  
  N+1 문제를 해결하기 위해 페치 조인(fetch join)기능을 활용한다.
  페치 조인(fetch join)이란 연관된 엔티티나 컬렉션을 한번에 같이 조회하는 기능을 의미한다.
  페치 조인을 할 경우 SQL 쿼리 한번으로 연관된 엔티티들을 함께 조회할 수 있어서 SQL 호출 회수를 줄여 성능을 최적화 할 수 있다
  
  페치 조인의 한계에는
  - 페치 조인 대상에는 별칭을 줄 수 없다
  JPA 표준에서는 지원하지 않지만 하이버네이트에서 페치 조인 대상에 별칭을 줄 수 있다
  하지만 별칭을 잘못 사용하면 연관된 데이터 수가 달라져 데이터 무결성이 깨질 수 있으므로 사용하지 않는것이 좋다
  
  - 컬렉션을 페치조인 할 경우 페이징 API(setFirstResult, setMaxResults)를 사용할 수 없다
  데이터가 많은데 페이징을 할 경우 몇개의 데이터들이 손실될 수 있으므로 페치조인을 할 경우 페이징 기능을 사용할 수 없다
  
  
- 컬렉션은 필드에서 바로 초기화 한다
  컬렉션은 필드에서 바로 초기화 하는 것이 안전하다.
  null 문제에서 안전하다 
  하이버네이트는 엔티티를 영속화 할 떄 컬렉션을 감싸서 하이버네이트가 제공하는 내장 컬렉션으로 변경해서 관리하는데
  만약 getOrders() 처럼 임의의 메서드에서 컬랙션을 잘못 생성하면 하이버네이트 내부 메커니즘에 문제가 발생할 수 있다
  그래서 컬렉션은 필드에서 바로 초기화해서 사용하는것이 좋다.
  
  
- 테이블, 컬럼명 생성 전략
  스프링 부트에서 하이버네이트 기본 매핑 전략을 변경해서 실제 테이블 필드명은 다르다
  
  하이버네이트의 기본 매핑 전략은 엔티티의 필드명을 그대로 테이블의 컬럼명으로 사용한다
  스프링 부트의 매핑 전략은 
  엔티티의 필드명을 카멜케이스에서 언더스코어로 변경하고
  .을 _로 변경하고
  대문자를 소문자로 변경한다
  
  
2. 애플리케이션 개발
- 인터넷 주문 서비스를 개발한다.
  애플리케이션은 
  controller, web) 웹 계층을 담당한다
  service) 비즈니스 로직, 트랜잭션을 처리한다
  repository) JPA를 직접 사용하는 계층이고 엔티티 매니저를 사용한다
  domain) 엔티티가 모여 있는 계층이고 모든 계층에서 사용한다.
  
  개발 순서는 서비스 / 리포지토리 계층을 개발하고 테스트 케이스를 작성해서 검증 마지막에 웹 계층을 적용한다.
  
  회원 리포지토리)
  회원 리포지토리는 회원을 저장할 
  save() 메서드 / 아이디로 회원을 찾는 findOne()메서드 / 전체 회원을 찾는 findAll() 메서드 / 이름으로 멤버를 찾는findByName() 메서드가 있다 
  리포지토리에서 데이터 베이스의 저장 / 관리 / 삭제 작업을 처리할 EntityManager를 생성한다.
  EntityManager를 SpringBean으로 등록하기 위해 @PersistenceContext 어노테이션이나 @Autowired 어노테이션을 사용해야되는데
  Lombok 기능을 이용하여 @RequiredArgsConstructor 어노테이션을 이용하여 생성자 주입으로 EntityManager를 SpringBean으로 등록한다
  (@RequiredArgsConstructor 어노테이션은 final 맴버 변수로 생성자를 만드는 어노테이션이다)
  
  의존성 주입 방법은
  생성자 주입 방법 / Setter 주입 방법 / 필드 주입 방법이 있다
  
  생성자 주입 방법은 생성자의 호출 시점에 1회 호출 되는것이 보장된다 
  그러므로 주입받은 객체가 변하지 않거나 반드시 객체의 주입이 필요한 경우에 강제하기 위해 사용할 수 있다.
 
  수정자 주입 방법은 Setter를 통해서 의존관계를 주입하는 방법이다
  주입 받는 객체가 변경될 경우에 사용된다 (하지만 주입받는 객체가 변경될 가능성은 극히 드물다)
  
  필드 주입 방법은 필드에 바로 의존관계를 주입하는 방법이다
  하지만 외부에서 접근이 불가능하다는 단점도 있고 테스트 코드에서 의존받는 객체를 접근할 수 없어 추천하지 않는 방법이다
  
  의존성 주입 방법에서는 생성자 주입 방법을 추천하는데
  생성시 1번만 초기화 되므로 객체의 불변성을 확보할 수 있다는 장점이 있다.
  생성자로 의존받는 객체에 접근이 가능하므로 순수한 자바 코드로 단위 테스트를 작성하는것이 쉽다는 장점이 있다.
  순환 참조 에러를 방지할 수 있다는 장점이 있다
  
  그러므로 의존성 주입 방법에서 생성자 주입 방법을 추천한다
  
  findAll() 메서드나 findByName() 메서드는 직접 JPQL 쿼리를 작성해서 가져왔다
  (SQL은 테이블 대상으로 쿼리, 조회를 하고 / JPQL은 엔티티 대상으로 조회한다)
  
