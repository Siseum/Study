# 2022 07 07 Study

1. 싱글톤
- 스프링은 객체를 싱글톤 패턴으로 관리한다
  여러 고객이 웹 애플리케이션에 요청할때마다 새로운 객체를 생성하면 
  메모리 낭비가 심하므로 싱글톤 패턴으로 클래스 인스턴스를 1개만 생성하여 공유되도록 객체를 관리한다
  
- 싱글톤 패턴은 클래스 인스턴스가 1개만 생성된다는 장점이 있다
  싱글톤 패턴의 단점은 
  싱글톤 패턴을 구현하는 단점은 싱글톤 패턴을 구현하는 코드 자체가 많다
  의존 관계상 클라이언트가 구체 클래스에 의존하므로 DIP(의존 관계 역전의 원칙)을 위반한다
  유연성이 낮고 테스트 하기가 어렵다
  내부 속성을 변경하거나 초기화가 어렵다
  
- 스프링 컨테이너는 싱글톤 패턴을 적용하지 않아도 객체 인스턴스를 싱글톤으로 관리하므로
  싱글톤 패턴의 단점은 해결하면서 모든 객체를 싱글톤으로 유지할 수 있다는 장점이 있다
  (싱글톤 패턴을 위한 코드를 넣지않아도 되며 DIP, OCP, 테스트, private 생성자로부터 자유롭게 싱글톤을 사용할 수 있다)
  
  스프링 컨테이너란 자바 객체의 생명 주기를 관리하고 생성된 자바 객체들에게 추가적인 기능을 제공하는 역할을 한다.
  (스프링 프레임워크가 관리하는 자바 객체를 스프링 빈이라고 한다)
  
- 싱글톤 방식은 여러 클라이언트가 하나의 객체 인스턴스를 공유하므로 싱글톤 객체는 상태를 유지하게 설계하면 안된다.
  특정 클라이언트에 의존적인 필드가 있으며 안된다
  특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다
  가급적 읽기만 가능해야된다
  스프링 빈의 필드에 공유 값을 설정하면 큰 문제가 발생할 수 있다.
  
  
- @Configuration 어노테이션이란 스프링 프레임 워크에서 설정파일을 만들거나 스프링 빈을 등록하기 위한 어노테이션이다
  @Configuration을 적용하면 바이트 코드 조작 라이브러리를 이용하여 싱글톤을 보장한다.
  
  
- Spring Bean을 사용하는 이유는 
  객체를 싱글톤으로 관리함으로써 메모리를 최적화 할 수 있고
  DI(의존관계 주입)를 통해 Spring Bean을 생성하므로 클래스간의 의존도를 최소화 할 수 있다는 장점이 있다
  DI를 통해 스프링 빈을 생성하므로 구현 클레스에 의존하지 않아도 되므로 의존관계 역전의 원칙을 지킬 수 있고
  DI를 통해 스프링 빈을 생성하므로 구현 클래스를 수정하지 않고도 설계 구조를 변경할 수 있어 개방 폐쇄의 원칙을 지킬 수 있다
  IOC(제어의 역전)을 통해 객체의 제어는 스프링 프레임워크가 담당하게 되므로 생성과 구현 기능을 분리함으로써 개방폐쇄의 원칙을 지킬 수 있다.
  
  @Bean 어노테이션이란 개발자가 제어하는것이 불가능한 라이브러리를 수동으로 스프링 빈으로 등록하기 위해 사용하는 어노테이션이다.
  
 
- DI(의존관계 주입)이란
  외부에서 객체를 생성하고 관리하면서 의존 관계를 연결해주는 것을 의미한다.
  
  IOC(제어의 역전)이란
  메소드나 객체의 호출 작업을 프로그래머가 아닌 외부에서 결정되는것을 의미한다.
  
  
- 중첩 클래스를 스프링 빈으로 등록할 경우 중첩 클래스는 static 클래스로 만들어야 한다
  왜냐하면 중첩 클래스를 스프링 빈으로 등록할려는데 static 클래스가 아닐경우 외부 클래스가 생성되어야 
  내부 클래스를 사용할 수 있으므로 스프링 빈 등록시 중첩 클래스를 등록할 수 없게 되므로 에러가 발생한다
  그러므로 중첩 클래스를 스프링 빈으로 사용할려면 static 클래스로 만들어야 된다.
  
  
2. 컴포넌트 스캔
- 스프링 빈을 등록할 때 수동으로 스프링 빈을 등록할 경우 여러 문제가 발생할 수 있다
  그러므로 스프링 프레임 워크에서는 자동으로 자바 객체를 스프링 빈으로 등록시켜주는 컴포넌트 스캔이라는 기능을 제공해준다
  
- @Component 어노테이션이란 개발자가 작성한 클래스를 Spirng Bean으로 등록할때 사용하는 어노테이션이다.
  @ComponentScan 어노테이션이란 @Component 어노테이션이 붙은 클래스를 스캔해서 스프링 빈으로 등록하는 어노테이션이다.
  
  @Controller 어노테이션은 스프링 MVC 컨트롤러에서 사용하는 어노테이션이다
  @Service 어노테이션은 스프링 비즈니스 로직에서 사용하는 어노테이션이다
  @Repository 어노테이션은 스프링 데이터 접근 계층에서 사용하는 어노테이션이다
  @Configuration 어노테이션은 스프링 설정 정보에서 사용하는 어노테이션이다
  
- @Autowired 어노테이션이란 의존 관계를 자동으로 주입해주는 어노테이션이다.
  
- 스프링 빈을 자동으로 등록할 수 있고 (@Component / @ComponentScan 을 사용해서)
  스프링 빈을 수동으로 등록할 수 있는데 (@Configuration / @Bean 을 사용해서)
  스프링 빈을 수동으로 등록하는것이 우선 순위가 있다
  (수동 빈이 자동 빈을 오버라이딩 한다)
  
  하지만 현실에서 개발자가 오버라이딩 하는 경우는 거의 없고 여러 설정들로 인해 
  의도치 않게 이러한 결과가 만들어지는 경우가 대부분이다
  그래서 최근 스프링 부트에서는 수동 빈과 자동 빈 등록이 충돌나면 오류가 발생하도록 기본 값을 변경하였다.
  
  
3. 의존관계 자동 주입
- 의존관계 주입은 4가지 방법이 있다
  생성자 주입 / 수정자 주입(setter 주입) / 필드 주입 / 일반 메서드 주입이 있다
  
  생성자주입은 생성자를 통해 의존 관계를 주입 받는 방법이다
  생성자 호출 시점에 한번만 호출되므로 불변 / 필수 의존관계에서 사용된다.
  
  수정자 주입(setter 주입)
  setter 수정자 메서드를 통해서 의존관계를 주입하는 방법이다
  선택 / 변경 가능성이 있는 의존 관계에서 사용된다
  (@Autowired 의 기본 동작은 주입할 대상이 없으면 에러가 발생한다
   주입할 대상이 없어도 동작하게 하려면 @Autowired(required = false)로 지정하면 된다.
  
  필드 주입
  필드에 바로 의존관계를 주입하는 방법이다
  코드가 간결해진다는 장점은 있으나 외부에서 변경이 불가능해서 테스트 하기 힘들다는 단점이 있다
  DI 프레임 워크가 없으면 의존관계 주입이 되지 않는다
  
  일반 메서드 주입
  일반 메서드를 통해 의존관계를 주입 받을 수 있다.
  한번에 여러 필드를 주입받을 수 있다
  일반적으로 잘 사용하지는 않는다
  
  참고로 순수한 자바 테스트 코드에서는 @Autowired 가 동작하지 않는다
  @SpringBootTest처럼 스프링 컨테이너를 테스트에 통합한 경우에만 가능하다.
  
  의존관계 자동 주입은 스프링 컨테이너가 관리하는 스프링 빈이여야 동작한다
  스프링 빈이 아닌 클래스는 @Autowired 코드를 적용해도 의존관계 자동 주입이 되지 않는다.
  
  
- 옵션처리
  주입할 스프링 빈이 없어도 동작해야 되는 경우가 있다
  그런데 @Autowired만 사용하면 required 옵션의 기본값이 true로 되어 있어서 자동 주입 대상이 없으면 오류가 발생한다
  
  @Autowired(required=false) 자동 주입할 대상이 없으면 수정자 메서드 자체가 호출되지 않는다
  @Nullable 자동 주입할 대상이 없으면 null이 입력된다
  Optional<> 자동 주입할 대상이 없으면 Optional.empty가 입력된다.
  
  
- 생성자 주입으로 의존관계를 주입 하는것을 추천한다
  대부분의 의존관계 주입은 한번 일어나면 애플리캐이션 종료시점까지 의존관계를 변경할 일이 없다
  오히려 의존관계는 애플리케이션 종료 전까지 변하면 안된다
  수정자 주입을 사용하면 setter 메서드를 public으로 열어두어야 되는데
  누군가 실수로 변경할 수 도 있고 변경하면 안되는 메서드를 열어 두는 것은 좋은 설계 방법이 아니다
  생성자 주입은 객체를 생성할 때 한번만 호출 되므로 이후에는 호출되는 일이 없다 따라서 불변하게 설계할 수 있다.
  
  수정자 주입을 할 경우 객체의 의존관계 주입이 누락될 수 있다는 문제점이 있다
  하지만 생성자 주입을 할 경우 컴파일 에러가 발생하고 IDE에서 에러를 잡아주므로 생성자 주입을 추천한다.
  
  생성자 주입을 사용할 경우 필드에 final 키워드를 사용할 수 있는데
  그러므로 생성자에서 값이 설정되지 않는 에러를 컴파일 시점에서 찾아낼 수 있다는 장점이 있다.
  
  롬복을 사용할 경우 @RequiredArgsConstructor 어노테이션으로 생성자를 쉽게 생성할 수 있다는 장점이 있다.
  
- @Autowired 어노테이션은 타입으로 빈을 조회하는데 조회 빈이 2개 이상일 경우 문제가 발생한다
  조회 빈 중복을 해결하기 위해 하위타입을 설정할 수 있지만 DIP를 위배한다는 문제점이 있다
  그리고 이름만 다르고 똑같은 타입의 스프링빈이 2개 있을때 해결이 되지않는다
  의존 관계 자동 주입에서 해결하는 여러 방법이 있다.
  
  @Autowired는 타입 매칭을 시도하고 여러개의 빈이 있을 경우 필드 이름 / 파라미터 이름으로 빈을 추가 매칭한다
  그러므로 필드 명을 매칭시키는 방법이 있다.
  
  @Qualifier 사용
  @Qualifier는 추가 구분자를 붙여주는 방법이다 
  (의존 관계 주입시 추가적인 방법을 제공하는 것이지 빈 이름을 변경하는것은 아니다)
  @Qualifier를 사용할 경우 의존관계를 주입 받을 때 모든 코드에 @Qualifier를 붙여주어야 한다
  
  @Primary 사용
  @Primary는 우선순위를 정하는 방법이다 
  @Autowired 시에 여러 빈이 매칭되면 @Primary가 우선권을 갖는다.
  
  @Qualifier와 @Primary의 우선순위는 수동으로 설정하는 @Qualifier가 우선순위를 갖는다.
  
  
4. 빈 생명주기 콜백
   스프링 빈은 객체 생성 > 의존관계 주입이라는 라이프 사이클을 갖는다
   스프링 빈은 객체를 생성하고 의존관계 주입이 다 끝난 다음에야 데이터를 사용할 수 있는 준비가 완료된다
   스프링은 의존관계 주입이 완료되면 스프링 빈에게 콜백 메서드를 통해 초기화 시점을 알려주는 다양한 기능을 제공한다
   그리고 스프링 컨테이너가 종료되기 직전에 소멸 콜백을 준다 
   
   초기화 콜백은 빈이 생성되고 빈의 의존관계 주입이 완료된 후에 호출한다
   소멸전 콜백은 빈이 소멸되기 직전에 호출한다.
   
   스프링은 인터페이스 / 설정 정보에 초기화 메서드, 종료 메서드 지정 / @PostConstruct, @PreDestroy 어노테이션을 지원한다.
   
   인터페이스 방법으로 빈 생명주기 콜백을 구현할 경우 
   해당 클래스에 InitializingBean 인터페이스를 상속하여 afterPropertiesSet() 메서드로 초기화 콜백을 지원하고
   DisposableBean 인터페이스를 상속하여 destroy() 메서드로 소멸전 콜백을 지원한다
   
   초기화 / 소멸 인터페이스의 단점은 스프링 전용 인터페이스에 의존한다
   초기화 소멸 메서드의 이름을 변경할 수 없다
   프로그래머가 변경할 수 없는 외부 라이브러리에 적용할 수 없다는 단점이 있다
   초기화 / 소멸 인터페이스 방법은 거의 사용하지 않는다
   
   설정 정보를 사용해서 빈 생명주기 콜백을 설정할 경우 
   @Bean(initMethod = "init", destroyMethod = "close") 처럼 초기화, 소멸 메서드를 지정할 수 있다.
   
   설정 정보 사용의 특징은
   메서드 이름을 자유롭게 설정할 수 있따
   스프링 빈이 스프링 코드에 의존하지 않는다
   코드가 아니더라도 설정 정보를 사용하기 때문에 코드를 고칠 수 없는 외부 라이브러리에도 초기화 / 종료 메서드를 적용할 수 있다.
   
   @PostConstruct / @PreDestroy 어노테이션으로 빈 생명주기 콜백을 설정할 수 있다
   
   @PostConstruct / @PreDestroy 어노테이션의 특징은
   최신 스프링에서 권장되는 방법이다
   어노테이션 하나만 추가하면 되므로 매우 편리하다
   외부 라이브러리에는 적용하지 못하므로 외부 라이브러리를 초기화 / 종료해야된다면 @Bean의 기능을 이용한다
   
   빈 생명주기 콜백을 설정하는데 추천하는 방법은
   @PostConstruct / @PreDestroy 어노테이션 사용을 추천한다.
   

 
