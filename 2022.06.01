# 2022 06 01 Study

1. 엔티티를 페치 조인 할 경우 원하지 않는 정보까지 가져오므로 성능문제가 발생할 수 있다
   그래서 조회 전용 Query DTO를 새로 만들어 JPA에서 조회할때부터 필요한 정보들만 조회하여 성능 최적화를 할 수 있다
   (SELECT 문장에서 DTO를 new 키워드를 사용하여 새로 생성해야되는데 해당 DTO의 경로까지 다 작성해줘야 된다)
   
   만약 일대다 연관관계 엔티티를 조회일때 다쪽의 데이터로 인해 중복된 데이터가 생성될 수 있으므로 
   일쪽의 데이터를 하나씩 순회하면서 다쪽의 데이터를 일일히 추가해줌으로써 다쪽으로 인한 중복데이터 없이 조회할 수 있다
   예) Order Entity는 일쪽 OrderItem은 다쪽이라면 먼저 Order 엔티티를 조회하고 
       Order Entity를 하나씩 순회하면서 Order Entity에 해당한 OrderItem Entity를 리스트로 가져온다
       그리고 Order Entity에 해당하는 OrderItem Entity를 일일히 하나씩 등록해준다
       
    이러한 방식의 문제점은 Order를 하나씩 순회하므로 N+1 문제가 발생할 수 있다는 문제점이 있다
       

2. Order Entity를 하나씩 조회해서 쿼리를 전송하는 방법은 성능상의 문제가 생길 수 있다
   그러므로 개선방안은 먼저 Order Entity를 조회하고 Order Entity의 Id를 List orderIds로 따로 저장한다
   그리고 SQL 쿼리 in 키워드와 orderIds를 이용하여 한꺼번에 OrderItem Entity를 가져온다
   조회해온 OrderItem Entity를 Map으로 변환하여 O(1) 시간으로 Order Entity와 OrderItem Entity를 매핑한다.
   이러면 쿼리의 전송 회수가 1번(Order Entity 조회) + 1번(OrderItem Entity 조회) 총 2번으로 성능 최적화를 했다
   
 
 3. 쿼리를 1번으로 최적화하고 싶다면 다쪽에 포함되는 엔티티도 함꼐 페치조인으로 가져온다
    그리고 Java 코드내에서 중복을 제거해서 사용한다
    쿼리가 한번만 발생한다는 장점이 있지만 애플리케이션에서 중복을 제거해야되는 로직과 중복되는 데이터를 저장하는 메모리 공간이 필요하므로 
    위의 방법과 비교하여 오히려 더 느려질 수 있다는 문제점이 있다.
    
    정리하자면 먼저 엔티티 조회 방식으로 우선 접근한다
    먼저 페치조인으로 일쪽인 엔티티를 한꺼번에 가져와서 쿼리수를 최적화 한다 
    (일쪽의 엔티티는 데이터가 중복되지 않으므로 페치조인을 사용해도 된다)
    다쪽의 조회도 필요할 경우
    페이징이 필요없다면 페치 조인과 distinct 명령어로 컬렉션 조회 최적화를 하면 된다
    페이징이 필요하다면 hibernate.default_batch_fetch_size, @BatchSize를 사용하여 컬렉션 조회와 페이징 처리를 하면된다
    
    만약 엔티티 조회 방식으로 해결이 안되면 조회 DTO를 생성할여 조회한다
    DTO 조회 방시곧 해결이 안되면 NativeSQL or JdbcTemplate를 사용한다.
    (엔티티를 직접 조회할 경우 페치 조인이나, hibernate.default_batch_fetch_size, @BatchSize 같이 코드를 거의 수정하지 않고
    옵션만 약간 변경해서 다양한 성능 최적화를 시도할 수 있다 반면에 DTO를 직접 조회하는 방식은 성능을 최적화 하거나
    성능 최적화 방식을 변경할 때 많은 코드를 변경해야된다)
    
    
    
    
