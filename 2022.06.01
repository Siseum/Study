# 2022 06 01 Study

1. 엔티티를 페치 조인 할 경우 원하지 않는 정보까지 가져오므로 성능문제가 발생할 수 있다
   그래서 조회 전용 Query DTO를 새로 만들어 JPA에서 조회할때부터 필요한 정보들만 조회하여 성능 최적화를 할 수 있다
   (SELECT 문장에서 DTO를 new 키워드를 사용하여 새로 생성해야되는데 해당 DTO의 경로까지 다 작성해줘야 된다)
   
   만약 일대다 연관관계 엔티티를 조회일때 다쪽의 데이터로 인해 중복된 데이터가 생성될 수 있으므로 
   일쪽의 데이터를 하나씩 순회하면서 다쪽의 데이터를 일일히 추가해줌으로써 다쪽으로 인한 중복데이터 없이 조회할 수 있다
   예) Order Entity는 일쪽 OrderItem은 다쪽이라면 먼저 Order 엔티티를 조회하고 
       Order Entity를 하나씩 순회하면서 Order Entity에 해당한 OrderItem Entity를 리스트로 가져온다
       그리고 Order Entity에 해당하는 OrderItem Entity를 일일히 하나씩 등록해준다
       
    이러한 방식의 문제점은 Order를 하나씩 순회하므로 N+1 문제가 발생할 수 있다는 문제점이 있다
       

2. Order Entity를 하나씩 조회해서 쿼리를 전송하는 방법은 성능상의 문제가 생길 수 있다
   그러므로 개선방안은 먼저 Order Entity를 조회하고 Order Entity의 Id를 List orderIds로 따로 저장한다
   그리고 SQL 쿼리 in 키워드와 orderIds를 이용하여 한꺼번에 OrderItem Entity를 가져온다
   조회해온 OrderItem Entity를 Map으로 변환하여 O(1) 시간으로 Order Entity와 OrderItem Entity를 매핑한다.
   이러면 쿼리의 전송 회수가 1번(Order Entity 조회) + 1번(OrderItem Entity 조회) 총 2번으로 성능 최적화를 했다
   
 
3.  쿼리를 1번으로 최적화하고 싶다면 다쪽에 포함되는 엔티티도 함꼐 페치조인으로 가져온다
    그리고 Java 코드내에서 중복을 제거해서 사용한다
    쿼리가 한번만 발생한다는 장점이 있지만 애플리케이션에서 중복을 제거해야되는 로직과 중복되는 데이터를 저장하는 메모리 공간이 필요하므로 
    위의 방법과 비교하여 오히려 더 느려질 수 있다는 문제점이 있다.
    
    정리하자면 먼저 엔티티 조회 방식으로 우선 접근한다
    먼저 페치조인으로 일쪽인 엔티티를 한꺼번에 가져와서 쿼리수를 최적화 한다 
    (일쪽의 엔티티는 데이터가 중복되지 않으므로 페치조인을 사용해도 된다)
    다쪽의 조회도 필요할 경우
    페이징이 필요없다면 페치 조인과 distinct 명령어로 컬렉션 조회 최적화를 하면 된다
    페이징이 필요하다면 hibernate.default_batch_fetch_size, @BatchSize를 사용하여 컬렉션 조회와 페이징 처리를 하면된다
    
    만약 엔티티 조회 방식으로 해결이 안되면 조회 DTO를 생성할여 조회한다
    DTO 조회 방시곧 해결이 안되면 NativeSQL or JdbcTemplate를 사용한다.
    (엔티티를 직접 조회할 경우 페치 조인이나, hibernate.default_batch_fetch_size, @BatchSize 같이 코드를 거의 수정하지 않고
    옵션만 약간 변경해서 다양한 성능 최적화를 시도할 수 있다 반면에 DTO를 직접 조회하는 방식은 성능을 최적화 하거나
    성능 최적화 방식을 변경할 때 많은 코드를 변경해야된다)
    
    
4. Open Session In View 전략이란 최초 데이터 베이스 커넥션 시작에서 API 응답이 끝날 떄 까지 영속성 컨텍스트와 
   데이터 베이스 커넥션을 유지하는 전략이다 OSIV 옵션의 기본값이 true이므로 API에서 지연 로딩이 가능했다
   (지연 로딩은 영속성 컨텍스트가 살아있어야 가능하고 영속성 컨텍스트는 기본적으로 데이터베이스 커넥션을 유지한다)   
   OSIV 전략은 지연로딩을 가능하게 해준다는 장점이 있다.
   
   하지만 OSIV 전략은 너무 오래동안 데이터 베이스 커넥션 리소스를 사용하기 때문에 
   실시간 트래픽이 중요한 애플리케이션에서는 커넥션이 부족할 수 있고 심각한 에러로 이어질 수 있다.
   (컨트롤러에서 외부 API를 호출하면 API 대기 시간만큼 커넥션 리소스를 반환하지 못하고 유지해야된다)
    
   OSIV 옵션을 끄면 트랜잭션을 종료할 떄 영속성 컨텍스트를 닫고 데이터베이스 커넥션도 반환하므로
   커넥션 리소스를 낭비하지 않는다는 장점이 있다
   
   하지만 OSIV 옵션을 끄면 지연로딩을 트랜잭션 안에서 처리해야 되므로 지연 로딩의 코드를 트랜잭션 안으로 넣어야 된다는 단점이 있다
   그리고 view template에서 지연로딩이 동작하지 않는다는 단점이 있다
   OSIV 옵션을 끌 경우 트랜잭션이 끝나기 전에 지연 로딩을 강제로 호출해 두어야 한다.
    
   실무에서 실시간 트래픽이 중요해서 OSIV를 끌 경우 
   핵심 비즈니스 로직과 화면이나 API에 맞춘 서비스(읽기 전용 트랜잭션 사용)를 분리하여 코드를 작성하는 방법이 있다
    
    
